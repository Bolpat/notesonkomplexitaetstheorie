%!TEX root = 0-main.tex

% Author: Philipp Moers <soziflip@gmail.com> 




\chapter{NP und P} % (fold)
\label{cha:np_und_p}
        

\section{Padding}

\begin{definition}
    Sei $L \subseteq \Sigma^\ast$ eine Sprache.

    % (Blase: 2^?  ist die Paddingfunktion geht auch für andere P.fkt.)
    % TODO verstehen, anpassen, einkommentieren

    $$ padd(L) = \{1^l O x | x \in L, l = 2^{|x|} \} $$
\end{definition}


\begin{satz}
    
    Es gilt: 
    $ L \in DTIME(f(s^n)) $, dann ist
    $$ padd(L) \in DTIME(f(n)) $$
    Blase $f$ zeitkonstant und insbesondere $f(n) \geq n$

\end{satz}

\begin{beweis}
    
    Sei $T$ eine deterministische Turingmaschine für $L$ und
    % TODO \leq \in ?
    $DTIME_T(x) \leq \in x f(2^n)$

    Die folgende Maschine $T'$ entscheided $padd(L)$:

    Gegeben Eingabe $y$, schreibe $y + 1^l O x$ und prüfe ob $l = 2^{|x|}$
    geht in Zeit $\bigO(|y|)$

    Aufwand: 
    $c f(2^{|x|}) \leq c * f(|y|)$

    Gesamtaufwand:
    $\leq c * f(|y|) + |y|
    = \bigO(f(|y|))$

    falls $f(n) \geq n$ (zeitkonstruierbar)
\end{beweis}




\begin{satz}
    Umgekehrt gilt auch:

    Wenn $padd(L) \in DTIME(f(n))$
    dann $L \in DTIME(f(s^{n+1}))$
\end{satz}

\begin{beweis}
    Sei $T$ eine Turingmaschine für $padd(L)$
    mit $DTIME_T(y) \leq c f(|y|)$

    Wir bauen eine Maschine für $L$:
    Gegeben Eingabe $x$, bilde $y = 1^{2^{|x|}} O x $.

    Aufwand: $\bigO(2^{|x|})$
    Setze $T$ auf $y$ an.
    Aufwand: $c * f(|y|) = c * f(2^{|x|} + |x| + 1)$

    Gesamtaufwand:
    $\bigO(f(2^{|x|+1}))$
\end{beweis}




\section{Was wenn P = NP}

\begin{satz}
    Folgerung:
    $$\ComplexityClassP = \ComplexityClassNP \Rightarrow \ComplexityClassE = \ComplexityClassNE$$
\end{satz}
\begin{beweis}
    Sei $P = NP$
    und $L \in NE$ und $T$ eine Maschine mit Aufwand $n^{kk}$
    wobei $k$ fest, $n$ Länge der Eingabe.
    
    $L \in NTIME(n^{nk}) = NTIME((2^n)^k)$
    Also $padd(L) \in NTIME(2^k)$
    also $padd(L) \in  NP$ und nach Annahme $padd(L) \in P$

    Also $padd(L) \in DTIME(n^{k'})$
    also $L \in DTIME((2^{n+1})^{k'})
    = DTIME(2^{k'n + k'}) = DTIME(2^{k'n}) \subseteq E$
\end{beweis}



Slogan: Gleichheit von Komplexitätsklassen vererbt sich nach oben.

Mit anderen Paddingfunktion zeigt man ebenso:

$$ \ComplexityClassP = \ComplexityClassNP \Rightarrow \ComplexityClassEXP = \ComplexityClassNEXP $$
$$ \ComplexityClassE = \ComplexityClassNE \Rightarrow \ComplexityClassEXP = \ComplexityClassNEXP $$

Kontrapositiv ausgedrückt:

$$ \ComplexityClassE \neq \ComplexityClassNE \Rightarrow \ComplexityClassP \neq \ComplexityClassNP $$ etc.


Es koennte sein, dass $\ComplexityClassP \neq \ComplexityClassNP$ aber doch $\ComplexityClassE = \ComplexityClassNE$.

Slogan: Trennung von Komplexitätklassen vererbt sich (durch Padding) von oben nach unten.




\section{Sogenannte Effizienz}


$\ComplexityClassP$ wird gemeinhin gleichgesetzt mit ``effizient loesbar''.
    
Wachstumsverhalten:

  $p$ Polynom. $\Rightarrow$ 
  $$ \exists c > 0:   p(2n) \leq c * p(n) $$

  Bei Verdopplung des Inputs wird der Output also ver-$c$-facht.

  Häufig hat eine Bruteforce-Lösung (``stures Durchprobieren'')
  exponentiellen und eine echte algorithmische Lösung hat polynomiellen Aufwand.











\datum{09.11.15}


\section{Polynomialzeitreduktionen}



\begin{definition}

    $f : \Sigma^\ast \rightarrow \Sigma^\ast $
    beziehungweise für Binärkodierung
    $f : \N \rightarrow \N $

    ist in \definiere{$\ComplexityClassFP$} (eine \definiere{in Polynomialzeit berechenbare Funktion}) genau dann, wenn eine polynomialzeitbeschränkte (deterministische) Transducer-Maschine existiert, die $f$ berechnet.

\end{definition}


Gegeben Input $x \in \Sigma^\ast$, dann hält die Maschine nach $\leq p(|x|)$ Schritten mit Ergebnis $f(x)$, wobei $p$ ein Polynom ist.

\begin{beispiel}
    
    \textbf{Musterbeispiele:}

    \begin{itemize}
        \item Alle Polynome sind in $\ComplexityClassFP$, zum Beispiel $f(x) = x^3 + 10x^2 + x$
        \item Charakteristische Funktionen aller Probleme in $\ComplexityClassP$ sind in $\ComplexityClassFP$.
        \item Matrixmultiplikation ist in $\ComplexityClassFP$.
    \end{itemize}

    \textbf{Gegenbeispiele:}

    \begin{itemize}
        \item $f(x) = 2^x$ ist nicht in $\ComplexityClassFP$, denn $|2^x| = x + 1 \geq 2^{|x| + 1} +  1 = \Omega(2^{|x|})$
        \item Charakteristische Funktionen von Problemen in $\ComplexityClassEXP \setminus \ComplexityClassP$  sind nicht in $\ComplexityClassFP$.
    \end{itemize}

    \textbf{Wahrscheinliches Gegenbeispiel:}

    $f(n) = \text{größter Teiler von } n \text{ außer } n \text{ selbst.}$
    Algorithmus: Alle Zahlen von 1 bis $n$ durchlaufen und testen, immer merken, wenn größerer Teiler gefunden.\\
    Laufzeit: $\Omega(n) = \Omega(2^{|n|})$ (Länge der Eingabe statt Zahl selbst)

\end{beispiel}




\begin{satz}
    $\ComplexityClassFP$ ist unter Komposition (Hintereinanderausführung) abgeschlossen.\\
\end{satz}
\begin{beweis}
    
    Seien $ f: \Sigma^\ast \rightarrow \Sigma^\ast, g : \Sigma^\ast \rightarrow \Sigma^\ast \in \ComplexityClassFP $

    Wir definieren $h(x) = g(f(x))$

    Programm für $h$: $y = f(x);\ z = g(y);\ return z;$\\
    Gesamtaufwand: $O(p_f(|x|) + p_g(p_f(|x|))$, wobei $p_f$ und $p_g$ Polynome sind, die die Laufzeit für Algorithmen für $f$ bzw. $g$ beschränken.
\end{beweis}




\begin{definition}

    \definiere{Polynomielle Reduzierbarkeit}

    Seien $L_1, L_2a \subseteq \Sigma^\ast$.

    Wir sagen $L_1$ ist polynomiell auf $L_2$ reduzierbar (\definiere{$\ComplexityClassFP$-reduzierbar}) genau dann, wenn $f \in \ComplexityClassFP$ existiert, sodass $x \in L_1 \Leftrightarrow f(x) \in L_2$.

    Aus Algorithmus für $L_2$ erhält man einen für $L_1$, indem man $f(x)$ berechnet und prüft, ob das Ergebnis in $L_2$ liegt.

    In Zeichen: $L_1 \leq_p L_2$ oder $L_1 \leq L_2$, auch $f: L_1 \leq L_2$

\end{definition}


\begin{beispiel}
    
    3COL = $\{ G = (V,E)\ |\ G \text{ kann mit 3 Farben gefärbt werden, d.h. } \exists c: V \rightarrow \{r,g,b\} \text{ sodass } \forall (u, u') \in E: c(v) \neq c(u') \}$

    SAT = $\{ \phi\ |\ \phi \text{ aussagenlogische Formel die erfüllbar ist} \}$


    Behauptung: 3COL $\leq$ SAT



    % $f((V,E)) = (\bigwedge \bigvee         x_{v,y}  )      \land      \bigwedge   \bigwedge    \bigwedge      x_{v,c} \rightarrow \neg x_{v,c'}$
    %             v \in V    y \in r,g,b                               v \in V      c \in r,g,b    c' \in r,g,b
    %                                                                                               c \neq c'

    %             $ \land    \bigwedge        \bigwedge         x_{v,y} \rightarrow \neg x_{v', y}$
    %                        (v,v') \in E     y \in {r,g,b}


    $$f((V,E)) = \left(     \bigwedge_{v \in V} \bigvee_{y \in \{r,g,b\}}    x_{v,y}    \right)         \land     $$ 

    $$ \left(     \bigwedge_{v \in V} \bigwedge_{c \in \{r,g,b\}} \bigwedge_{c' \in \{r,g,b\}}      x_{v,c} \rightarrow \neg x_{v,c'} \right)       \land     $$

    $$ \left(     \bigwedge_{(v,v') \in E} \bigwedge_{y \in \{r,g,b\}}    x_{v,y} \rightarrow \neg x_{v', y} \right) $$
                                


    Offensichtlich ist $f \in \ComplexityClassFP$ und $G \in \text{ 3COL } \Leftrightarrow f(G) \in \text{ SAT }$,\\ also 3COL $\leq$ SAT.

\end{beispiel}



\begin{beispiel}
    
    KNFSAT := wie SAT, aber auf konjunktive Normalform eingeschränkt.

    Es gilt trivialerweise KNFSAT $\leq$ SAT, aber auch SAT $\leq$ KNFSAT (Durch Einführung von Abkürzungen von Teilformeln).

\end{beispiel}

\begin{beispiel}
    
    3SAT := KNFSAT eingeschränkt auf Klauseln mit 3 Literalen.

    Es gilt KNFSAT $\leq$ 3SAT.

    Man kennt keine Reduktion von 3SAT auf 2SAT.

\end{beispiel}


\begin{beispiel}
    
    NODE-COVER := $\{ G = (V,E), n\ |\ \exists U \subseteq V: |U| \leq n \text{ und } \forall (v,v') \in E: v \in U \lor v' \in U \}$

    Es gilt NODE-COVER $\leq$ KNFSAT.

    und - was schwieriger zu zeigen ist - KNFSAT $\leq$ NODE-COVER:

    Gegeben: KNF $\phi$ mit $m$ Variablen $x_1 \dots x_m$ und $k$ Klauseln $C_1 \dots C_k$ wobei $C_j = l_{j,1} \lor \dots \lor l_{j,k}$\\
    Falls 3SAT, so sind alle $k_j = 3$.\\
    Die $l_{j,i}$ sind Literale, d.h. negierte oder nicht-negierte Variablen.

    Wir konstruieren Graphen $G = (V,E)$ wie folgt:
    \begin{itemize}
        \item Für jede Variable $x_t$ zwei Knoten $x_t, \neg x_t$
        \item Für jede Klausel $C_j$ $k_j$ Knoten $(l_{j,1}) \dots (l_{j,k})$,\\ Insgesamt $2m \Sigma_{j=1}^k k_j$ Knoten
        \item Kanten: 
        \begin{itemize}
            \item $(x_t, \neg x_t)$
            \item Vollständiger Graph für $l_{j,1} \text{ bis } l_{j,k}$
            \item $(x_t, l_{j,i})$ bzw. $(\neg x_t, l_{j,i})$, falls $l_{j,i} = x_t$ bzw. $l_{j,i} = \neg x_t$
        \end{itemize}
    \end{itemize}

\end{beispiel}





\section{NP-Härte und NP-Vollständigkeit}


\begin{definition}
    
    $L \subseteq \Sigma^\ast$ ist \definiere{$\ComplexityClassNP$-hart} ($\ComplexityClassNP$-schwer, $\ComplexityClassNP$-schwierig) genau dann, wenn 

    $$ \forall L' \in \ComplexityClassNP: L' \leq_p L $$

\end{definition}


\begin{satz}
    HALT (Halteproblem) ist NP-hart.
\end{satz}
\begin{beweis}
    Gegeben: $L' \in \ComplexityClassNP$. Baue deterministische Turingmaschine $M$, sodass $M(x)$ hält genau dann, wenn $x \in L'$ Brute-force Suche, Laufzeit exponentiell.\\
    $x \in L' \Leftrightarrow (M, x) \in \text{ HALT } $\\
    also ist $f(x) = (M,x)$ eine Reduktion von $L'$ auf HALT $f: L' \leq \text{ HALT }$.
\end{beweis}



\begin{definition}

    $L \subseteq \Sigma^\ast$ ist \definiere{NP-vollständig} genau dann, wenn $L$ NP-hart ist und $L \in \ComplexityClassNP$.

\end{definition}


\begin{satz}
    HALT $\notin \ComplexityClassNP$.
\end{satz}



\begin{satz}
    \definiere{Satz von Cook}

    SAT ist NP-vollständig.
\end{satz}

\begin{beweis}
    
    SAT $\in \ComplexityClassNP$: trivial.

    Sei $L \in \ComplexityClassNP$ gegeben und o.B.d.A $M$ eine nichtdeterministische Turingmaschine für $L$ mit einem Band $M = (\Sigma, Q, q_0, F, I)$ und $p$ ein Polynom, das die Laufzeit von $M$ beschränkt.
    Gegeben weiterhin $x = x_1 \dots x_n$ Input.

    Gesucht: aussagenlogische Formel $\phi = f(x)$, sodass $\phi$ erfüllbar ist genau dann, wenn $M$ akzeptiert $x$. $q$ muss aus $x$ in polynomieller Zeit berechenbar sein, d.h. $f \in \ComplexityClassFP$.

    $M$ akzeptiert $x$ genau dann, wenn eine akzeptierende Berechnung von $M$ auf $x$ existiert. Solch eine Berechnung hat höchstens $p(n)$ Schritte und o.B.d.A genau $p(n)$ Schritte. Die Bandbeschriftung zu jedem dieser $p(n)$ Schritte besteht aus höchstens $p(n)$ Symbolen und o.B.d.A genau $p(n)$ Symbolen.

    Die Formel $\phi$ verwendet die Variablen 
    \begin{itemize}
        \item $Q_t^i$: Zur Zeit $t$ ist $M$ im Zustand $i$.
        \item $P_{s,t}^i$: Zur Zeit $t$ enthält Bandposition $s$ das $i.$ Symbol.
        \item $S_{s,t}$: Zur Zeit $t$ ist der Kopf in Position $s$.
    \end{itemize}

    $$ q = A \land B \land C \land D \land E \land F $$

    \textit{Details im Buch\dots}

\end{beweis}


3SAT, NODE-COVER sind auch NP-vollständig.

Allgemein gilt: $L$ NP-vollständig und $L' \in \ComplexityClassNP, L \leq L'$ 
so folgt $L'$ NP-vollständig.


\textbf{Anmerkung:}
$\leq$ ist transitiv, da $\ComplexityClassFP$ unter Komposition abgeschlossen ist.

\textbf{Anmerkung:}
3COL, TRAVELINGSALESMAN, SUBSETSUM etc. sind auch NP-vollständig.












\datum{12.11.15}


\section{Etwas zwischen P und NP}



\begin{satz}
    
    \definiere{Satz von Ladner}

    Falls $\ComplexityClassP \neq \ComplexityClassNP$, dann

    $$ \exists A \in \ComplexityClassNP \setminus \ComplexityClassP: A \text{ nicht NP-vollständig.} $$

    $A$ liegt also ``echt'' zwischen $\ComplexityClassP$ und NP-vollständig.

    
\end{satz}



\begin{definition}

    \definiere{Diagonalisierung}
    
    Um zu zeigen, dass eine Sprache $A$ nicht in einer Klasse $\mathcal{C}$ ist, beziehungweise um solch ein $A$ zu konstruieren, kann man eine effektive (FP) Aufzählung von Turingmaschine $(M_i)_i$ verwenden, sodass $\mathcal{C} = \{ L(M_i)\ |\ i \geq 0 \}$  und dann dafür sorgen, beziehungweise zeigen, dass $\forall i: A \neq L(M_i)$ beziehungweise $\forall i: A \triangle L(M_i) \neq 0$.\\
    Das heißt $\forall i \exists x: \left(x \in A \land x \notin L(M_i) \right) \lor \left( x \notin A \land x \in L(M_i) \right)$

\end{definition}


\begin{lemma}
    
    Es existiert eine FP-Funktion $i \mapsto M_i$, sodass $DTIME_{M_i}(x) \leq (|x| + 2)^2$ und $P = \{ L(M_i)\ |\ i \geq 0 \}$.

\end{lemma}

\begin{lemma}
    
    Es existiert eine FP-Funktion $i \mapsto f_i$ wobei $f_i$ eine Übersetzermaschine ist und $FP = \{ f_i\ |\ i \geq 0 \}$ und $DTIME_{f_i}(x) \leq (|x| + 2)^i$. Insbesondere $|f_i(x)| \leq (|x| + 2)^i$.

\end{lemma}

Es ist klar, dass $A \in \ComplexityClassNP$ aber $A \notin \ComplexityClassP$ und $A$ nicht NP-vollständig, wenn
\begin{itemize}
    \item $A \in NP$
    \item $\forall i \exists x: x \in A \triangle L(M_i)$
    \item $\forall i \exists x: x \in SAT \land f_i(x) \notin A \text{ oder } x \notin SAT \land f_i(x) \in A$
\end{itemize}

Das heißt $f_i$ ist keine Reduktion von $SAT$ auf $A$.





Wir konstruieren $A$ in der folgenden Form:

$$ A = \{  x \ |\   x \in SAT  \land   f(|x|) \text{ gerade.}  \} $$

$f$ wird sogleich rekursiv definiert derart, dass dieses $A$ die Bedingungen 1, 2 und 3 erfüllt.

Man sollte also versuchen sicherzustellen, dass 

\begin{itemize}
    \item 
    $f(n) in ZEit p(n)$ berechenbar für Polynom $p$ (Bedingung 1).

    \item 
    Für alle $i$ existiert $x$ mit \\
    $x \in SAT$ und $f(|x|)$ gerade und $x \notin L(M_i)$\\
    oder\\
    ($ x \notin SAT$ oder $f(|x|)$ ungerade ) und $x \in L(M_i)$\\

    \item 
    Für alle $i$ existiert $x$, sodass
    $x \in SAT$ und ($f(|f_i(x)|)$ ungerade oder $f_i(x) \notin SAT$\\
    oder\\
    $x \notin SAT$ und $f(|f_i(x)|)$ gerade und $f_i(x) \in SAT$\\

\end{itemize}


$f$ wird jetzt rekursiv definiert.\\
Wir schreiben $A_f = \{ x \ |\   x \in SAT  \land  f_(|x| \text{ gerade.}  \}$

\begin{equation*}
\begin{split}
f(n+1) = 
    IF    &\ \ (2 + \log \log n)^{f(n)} \geq \log n \\
    THEN  &\ \ f(n) \\
    ELIF  &\ \ \exists x: |x| \leq \log \log n \text{ und } x \in L(M_i) \land x \notin A_f \text{ oder } x \notin L(M_i) \land x \in A_f \\
    THEN  &\ \ f(n) + 1 \text{ ebe } f(n) \\
    ELIF  &\ \ \exists x: |x| \leq \log \log n \\
    THEN  &\ \ f(n) + 1
\end{split}
\end{equation*}

Um $f(n+1)$ zu berechnen wird rekursiv nur auf Werte $f(m)$ mit $m \leq n$ zugegriffen, also ist $f$ eine totale Funktion.

Es genügt, ein Polynom $p(n)$ zu finden, sodass in Zeit $p(n)$ der Wert $f(n+1)$ aus $f(0), f(1), \dots f(n)$ bestimmt werden kann.\\
Die Laufzeit für $f(n)$ ist nämlich dann $\bigO(\Sigma_{m < n} p(m)) = poly(n)$.


Klar ist, dass $A = A_f \neq L(M_i)$ falls $f(n) = 2i+1$ für ein $n$, denn dann war $f(n') = 2i$ für ein $n' < n$ und $f(n'+1) = 2i+1$ also die Suche in Fall 2 erfolgreich.

Ebenso ist $f_i$ keine Reduktion: $SAT \leq A_f$ falls $f(n) = (2i+1)+1$ für ein $n$.

Das heißt wir müssen zeigen, dass $f$ surjektiv ist, d.h. dass jeder Fall irgendwann erfolgreich abgeschlossen wird.

% Für festes $d$ wächst $(2 + \log n)^d$ langsamer als $n$, also wächst auch $ $ blabla

\textit{Details dazu auf der Website.}










% chapter np_und_p (end)
