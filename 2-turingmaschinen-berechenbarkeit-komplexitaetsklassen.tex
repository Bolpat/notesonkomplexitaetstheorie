%!TEX root = 0-main.tex

% Author: Philipp Moers <soziflip@gmail.com> 




\chapter{Turingmaschinen, Berechenbarkeit und Komplexität} % (fold)
\label{cha:turingmaschinen_berechenbarkeit_und_komplexitaet}


\datum{13.10.15}

\section{Turingmaschinen}


\begin{definition}
        
    Eine \definiere{Turingmaschine} $T$ mit $k$ Bändern ist ein 5-Tupel
    $$ T = (Q, \Sigma, I, q_0, F) $$
    \begin{itemize}
        \item $Q$ ist eine endliche Menge von Zuständen
        \item $\Sigma$ ist eine endliche Menge von Bandsymbolen, $\square \in \Sigma$
        \item $I$ ist eine Menge von Quintupeln der Form $(q, s, s', m, q')$ mit $q, q' \in Q$ und $s, s' \in \Sigma^k$ und $m \in \{ L, R, S \}^k$ 
        \item $q_0 \in Q$ Startzustand
        \item $F \subseteq Q$ Endzustände
    \end{itemize}

    $\square$ ist das Leerzeichen oder \definiere{Blanksymbol}.

    $T$ heißt \definiere{deterministisch} genau dann, wenn für jedes $q \in Q$ und $s \in \Sigma^k$ genau ein Quintupel der Form $(q, s, \_, \_, \_) \in I$ existiert. Sonst heißt $T$ \definiere{nichtdeterministisch}.

    Eine Turingmaschine heißt \definiere{Akzeptormaschine} genau dann, wenn zwei Zustände $q_A, q_R \in F$ speziell markiert sind. $q_A$ signalisiert Akzeptanz, $q_R$ signalisiert Verwerfen der Eingabe.

    Eine Turingmaschine heißt \definiere{Transducermaschine} genau dann, wenn ein zusätzliches Band ausgezeichnet ist (das Ausgabeband).

\end{definition}



\begin{beispiel}
    Akzeptormaschine $T$ für Sprache $L = \{ 0^n 1^n | n \geq 0 \}$ wobei $\Sigma= \{0,1\}, Q = \{q_0, \dots q_4 \}$

    $T$ wird deterministisch sein. $T = (Q, \Sigma, I, q_0, F), q_A = q_1, q_R = q_2, F = \{q_1, q_2\}, k=2$

    \vspace{2pt}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}\hline
    \rowcolor{grau} $q$   & $s_1$     & $s_2$     & $s_1'$    & $s_2'$    & $m_1$ & $m_2$ & $q'$    \\\hline
                    $q_0$ & $\square$ & $\square$ & $\square$ & $\square$ & $S$   & $S$   & $q_1$   \\\hline
                    $q_0$ & $0$       & $\square$ & $0$       & $0$       & $R$   & $R$   & $q_3$   \\\hline
                    $q_0$ & $1$       & $\square$ & $1$       & $\square$ & $S$   & $S$   & $q_2$   \\\hline
                    $q_3$ & $\square$ & $\square$ & $\_$      & $\_$      & $\_$  & $\_$  & $q_2$   \\\hline
                    $q_3$ & $0$       & $\square$ & $0$       & $0$       & $R$   & $R$   & $q_3$   \\\hline
                    $q_3$ & $1$       & $\square$ & $1$       & $\square$ & $S$   & $L$   & $q_4$   \\\hline
                    $q_4$ & $0$       & $0$       & $\_$      & $\_$      & $\_$  & $\_$  & $q_2$   \\\hline
                    $q_4$ & $1$       & $0$       & $1$       & $0$       & $R$   & $L$   & $q_4$   \\\hline
                    $q_4$ & $0$       & $\square$ & $\square$ & $\square$ & $S$   & $S$   & $q_1$   \\\hline
                    $\_$  & $\_$      & $\_$      & $\_$      & $\_$      & $\_$  & $\_$  & $q_2$   \\\hline
    \end{tabular}

\end{beispiel}


Die \definiere{globale Konfiguration} (oder der \definiere{Zustand}) einer Turingmaschine beinhaltet die Beschriftung aller Bänder, den internen Zustand ($\in Q$) und die Positionen aller $k$ Lese-/Schreibköpfe. Globale Konfigurationen können als endliche Wörter über einem geeigneten Alphabet (z.B. $\{0,1\}$) codiert werden.


Eine Turingmaschine \definiere{akzeptiert} eine Eingabe genau dann, wenn eine Berechnungsfolge ausgehend von dieser Eingabe existiert und in einem Zustand aus $F$ endet.

Eine Turingmaschine \definiere{akzeptiert} eine Sprache $L \subseteq \left( \Sigma \setminus \{\square\} \right)^\ast$ falls gilt: 
$$ \text{Die Turingmaschine akzeptiert } w \Leftrightarrow w \in L $$

Eine Turingmaschine \definiere{entscheidet} eine Sprache $L \subseteq \left( \Sigma \setminus \{\square\} \right)^\ast$ genau dann, wenn sie sie akzeptiert und eine/die Berechnung in $q_A$ endet.


\begin{definition}

\definiere{Nichtdet Zeitkomplexitaet}
Seit T eine nichtdet. TM, Fuer x \in \Sigma ist NTime_T(x)

\begin{enumerate}
\item definiert g.d.w. alles Berechnungen von T auf x halten
\item Falls definiert  und x \inL(T) (d.h. es gibt eine akyeptierende Ber. von T auf x)
  definiert als Laenge der kuerzesten akzeptierenden Berechnungen von T auf X.
\item Falls ueberhaupt definiert x \notin L(T) so ist NTIME_{(x)} die Laenge der kuerzesten Berechnung
\end{enumerate}

\end{definition}

\begin{definition}
  Nichtdeterministische Komplexitaetsklassen NTIME(f(n)) = { L | esox T L(T)=L und NTIME_T(x) = O(f(|x|))}

  Es gibt einen nichtdeterministischen Zeithierachiesatz.


  P=U DTIME(n^k), NP = U NTIME(n^k)
  k>=1                k>=1

  E = U DTIME(2^kn), NE= U NTIME(2^KN)
  k>=1               k>=1

  EXP = DTIME(2^n^k), NEXP= U NTIME(2^N^k)
  k>=1                k>=1


  Nichtdeterminismus kann durch exhaustive Suche deterministsch simuliert werden.
  z.B. NP \subseteq EXP


  Allgemein:
  NTIME(f(n)) \subseteq DTIME(2^O(f(n))
  ........\ --- Zeitkonstruierbar

  Charakteriserung von NP durch ``polynoielle Verizibierbakeit''

  L\subseteq \sigma * . L \in PV \Leftrightarrow

  eine Spraceh L' \in P existiert so dass gilt

  x\inL \Leftrightarrow  esex z ``Loesung'' mit |h|<=L'
  wobei p ein Polynom ist.

\end{definition}

\begin{satz}
  NP = PV
  Beweisskizze:
  ``S'' L \in NP . Sei T eine NTM fuer L mit Laufzeit p(n).

  L' = {(x,y) | y codiert eine akyeptierende Berechnung von T auf x}

  \begin{enumerate}
  \item x \in L \Leftrightarrow  \E y |y| <= (p(|x|))^2 . (x,y,) \in L'

  \item L' \in P

  \end{enumerate}


``\supseteq'' geg. L, L'\in P . Eine nicht det Turingmaschine T fuer L raet zunaechst y und prueft dann (x,y) \in L'
  
\end{satz}

Exp im Gegensartz zu NP bzw. PV umfasst auch Probleme mit exp. groesen Loesungen bzw solchen wo die Verifikation einer Loesung einen exponentiellen Aufwand macht.


% chapter turingmaschinen_berechenbarkeit_und_komplexitaet (end) 
